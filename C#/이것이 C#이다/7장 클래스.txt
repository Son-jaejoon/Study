1. 클래스의 종료자의 경우 가급적 사용하지 않는 것이 좋다.
- CLR의 가비지 컬렉터가 언제 동작할지 예측할 수 없다.
- 명시적으로 구현시 가비지 컬렉터는 객체로부터 상속받은 Finalize() 메소드를 호출한다. (성능 저하)
- CLR의 가비지 컬렉터는 우리보다 똑똑하다.

2. 클래스 내 static 메소드는 바로 접근 가능하다. 일반적인 경우는 인스턴스 메소드라고 한다.

3. 클래스는 참조가 기본.

4. this 생성자
- public MyClass(), public MyClass(int b) : this(), public MyClass(int b, int c) : this(b)

5. 클래스의 멤버는 기본적으로 private로 자동 지정 된다.

6. 접근 한정자
- public : 내부/외부 o
- protected : 외부접근 x, 파생클래스에서 접근 o
- private : 클래스 내부에서만 접근 o, 파생클래스에서 접근 x
- internal : 같은 어셈블리에 있는 코드에서만 public으로 접근 o, 다른 어셈블리에 있는 코드에서는 private 수준
- protected internal : 같은 어셈블리에 있는 코드에서만 protected, 다른 어셈블리에 있는 코드에서 private 수준
- private protected : 같은 어셈블리에 있는 클래스에서 상속받은 클래스 내부에서만 접근 가능

7. 형식 변환 연산자
- is : 객체가 해당 형식에 해당하는 지 검사하여 bool을 반환
- as : 형식 변환 연산자와 같은 역할을 하며, as 연산자는 실패시 객체 참조를 null로 만든다.(형식 변환 연산자는 예외 반환)

8. 오버라이드(재정의)
- 부모 클래스 virtual, 자식 클래스 override을 통해 다형성 실현
- 하위 클래스에서 계속 override하는 것을 방지할 수 있는 기능으로 sealed override을 할 시 해당 함수로 고정된다.
   (이후 재정의하려고 할 시 오류발생)

9. 읽기 전용 필드
- const, readonly
- readonly의 경우 생성자 안에서만 초기화할 수 있다.

10. 분할 클래스 : 클래스의 구현이 길어질 경우 여러파일에 나눠서 구현할 수 있게 함으로써 소스 코드 관리의 편의 제공
- partial class MyClass{}

11. 구조체
- 클래스는 실세계의 객체를 추상화하려는 이유, 구조체는 데이터를 담기 위한 자료구조
-> 이러한 이유로 편의를 위해 필드를 public으로 선언해서 사용하는 경우가 많다.
- 클래스와의 차이
 * 값 형식(상속 불가능) -> 스택에 할당되고 지점에 벗어나면 메모리에서 사라진다. (성능의 이점)
 * 깊은 복사
 * 선언만으로도 생성
 * 매개변수 없는 생성자 선언 불가능
- 변경불가능 구조체 선언 가능(클래스는 불가능) readonly struct MyStruct{}

// 위 내용은 '이것이 C#이다'를 공부한 후 작성한 내용입니다.