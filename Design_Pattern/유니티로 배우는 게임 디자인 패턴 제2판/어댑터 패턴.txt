어댑터 패턴 : 호환되지 않는 두 개의 인터페이스를 조정한다.
취약한 부분이 있어 리팩토링할 수 없는 레거시 코드를 다루어야 할 때나 업그레이드했을 때의 이슈를 피하기 위해
수정하기 싫지만 서드파티 라이브러리에 기능을 추가해야 할 때 유용하다.

* 주요 접근 방식
- 객체 어댑터 : 패턴은 객체 구성을 사용하고 어댑터는 조정한 객체의 래퍼(wrapper)처럼 행동한다.
	      원래 클래스의 메서드를 선택하고 우리가 필요한 것으로 조정한다.
- 클래스 어댑터 : 어댑터는 기존 클래스의 인터페이스를 다른 클래스의 인터페이스에 적용하기 위해 상속을 사용한다.
	          다른 클래스와 같이 작동해야 하지만 직접 수정할 수 없는 클래스를 조정해야 할 때 유용하다.

* 장점
- 수정 없이 조정 가능 : 오래된 코드나 서드파티 코드를 수정 없이 조정하는 표준 접근 방식을 제공한다.
- 재상용성 및 유연성 : 새로운 시스템에서 최소한의 변경만으로 레거시 코드를 계속 사용할 수 있다. 개발비용을 절약할 수 있다.

* 단점
- 지속적인 레거시 사용 : 새 시스템에서 레거시 코드를 사용하는 것은 비용 면에서 효율적이지만 장기적으로 보면 문제가 된다.
		  엔진 자체의 버전 업그레이드 혹은 서드파티 라이브러리에서 호환되지 않아 업그레이드 옵션이 제한될 수 있다.
- 약간의 성능 저하 : 경우에 따라 객체 간 호출을 리다이렉션하여 약간의 성능 저하가 발생할 수 있다.

* 어댑터 패턴을 사용하는 경우
- 유니티의 경우, 유니티의 에셋 스토어에서 다운로드한 서드파티 라이브러리가 있고 새로운 기능 추가를 위해
   핵심 클래스 및 인터페이스의 일부를 수정해야 할 때이다.
- EX) 이미 구현된 서버 인벤토리 시스템, 구현해야할 로컬 인벤토리 시스템, 인터페이스를 통해 통합시키기

//위의 내용은 유니티로 배우는 게임 디자인 패턴 제2판을 공부한 후 정리한 내용입니다.